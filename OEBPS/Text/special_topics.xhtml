<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<link href="../Styles/Style0001.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Chapter 10. Special topics<br/></h1>
This chapter touches several technical topics which might help you to get darktable running on specific hardware or optimize its performance. A lot of additional technical background information and many tips and tricks are also covered in an extensive blog section that you can find on our <a class="ulink" href="https://www.darktable.org/" target="_top">homepage</a>.<div><img alt="darktable_blog" src="../Images/darktable_blog.jpg" class="center"/><br/>&nbsp;
<h2 id="sigil_toc_id_87">10.1. darktable and memory<br/></h2>
<p>darktable's memory requirements are high. A simple calculation makes this clear. If you have a 20MPix image, darktable for precision reasons will store this internally as a 4 x 32-bit floating point cell for each pixel. Each full image of this size will need about 300MB of memory. As we want to process the image, we will at least need two buffers for each module  – one for input and one for output. If we have a more complex module, its algorithm might additionally require several intermediate buffers of the same size. Without further optimization, anything between 600MB and 3GB would be needed only to store and process image data. On top we have darktable's code segment, the code and data of all dynamically linked system libraries, and not to forget further buffers where darktable stores intermediate images for quick access during interactive work (mip map cache). All in all, darktable would like to see a minimum of about 4GB to run happily.</p>
<div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_812">10.1.1. Total system memory</h3>
</div>
</div>
</div>
<p>From what I said before, it is evident that your computer needs a sane memory setup to properly run darktable. We suggest that you have a least 4GB of physical RAM plus 4 to 8GB of additional swap space installed. The latter is required, so that your system can swap out temporarily unneeded data to disk in order to free physical RAM.</p>
<p>Theoretically, you could also run darktable with lower amounts of physical RAM and balance this with enough swap space. However, you should be prepared that your system could then heavily <span>“<span>thrash</span>”</span>, as it reads or writes data pages to and from the hard disk. We have positive reports that this functions well for several users, but it still might get extremely slow for others...</p>
</div>
<div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_814">10.1.2. Available address space</h3>
</div>
</div>
</div>
<p>Besides the total amount of system memory there is another limiting factor: the available address space of your hardware architecture. How much memory can be addressed by a process depends on the number of address bits your CPU offers. For a CPU with 32-bit address registers, this is 2^32 bytes, which makes a total of 4GB. This is the absolute upper limit of memory that can be used by a process and it constitutes a tight situation for darktable as we have seen above.</p>
<p>darktable's escape route is called tiling. Instead of processing an image in one big chunk, we split the image into smaller parts for every processing step (module). This will still require one full input and output buffer, but intermediate buffers can be made small enough to have everything fit into the hardware limits.</p>
</div>
<div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_815">10.1.3. Memory fragmentation</h3>
</div>
</div>
</div>
<p>Unfortunately this is not the full story yet. There is an effect called memory fragmentation, which can and will hit software that needs to do extensive memory management. If such a program allocates 5 times 300MB at a time and frees it again, that memory should normally be available for one big 1.5GB allocation afterwards. This however is often not the case. The system's memory allocator may no longer see this area as one contiguous 1.5GB block but as a row of 300MB areas. If there is no other free area of 1.5GB available, the allocation would fail. During a program run this mechanism will take away more and more of the larger memory blocks in favor of smaller ones. darktable 2.0 mip map cache allocates several small memory blocks per each thumbnail, so this problem is even bigger. For this reason, as of darktable 2.0, 32-bit support is soft-deprecated.</p>
</div>
<div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_816">10.1.4. Further limitations</h3>
</div>
</div>
</div>
<p>As if this were not challenging enough, there are further things that might limit your access to memory. On some older boards you need to activate BIOS option <span>“<span>memory remapping</span>”</span> in order to have all physically installed memory enabled. In addition if you are on a 32-bit OS you will probably need a kernel version that has <span>“<span>Physical Address Extension</span>”</span> (PAE) enabled. This is often but not always the case for Linux. Many distributions deliver different kernels, some with and some without PAE activated; you need to choose the right one. To check if the system is setup correctly, use the command <span>“<span>free</span>”</span> in a terminal and examine the output. If the output reports less RAM than you have installed, you have an issue needing correction; for example you have 4GB on your board, but your kernel is only seeing 3GB or less. You need to consult your BIOS manual and the information about your Linux variant for further help.</p>
</div>
<div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_817">10.1.5. Setting up darktable on 32-bit systems</h3>
</div>
</div>
</div>
<p>As we've seen 32-bit systems are difficult environments for darktable. Still some users are running darktable on them, if the basic requirements in terms of total system memory and the topics mentioned in the paragraphs above are addressed properly.</p>
<p>There are several adjustment parameters to get it running. If you install fresh, darktable will detect your system and set conservative values by default. However, if you upgrade darktable from an older version (e.g. coming from 0.9.3 and going to 1.0), chances are you have unfavorable settings in your preferences. The consequences might be darktable aborting due to allocation failures or – very typically – darktable not being able to properly import a new film roll. As a frequent symptom you get skulls displayed instead of thumbs for many of your pictures.</p>
<p>If this is the case, take a minute to optimize the preference settings in this case. You will find them under <span>“<span>core options</span>”</span> (<a title="8.2. Core options" href="../Text/preferences.xhtml#sigil_toc_id_5">Section 8.2, “Core options”</a>) in darktable's preference dialog. You should also find these parameters as configuration variables in $HOME/.config/darktable/darktablerc and edit them there.</p>
<p>Here is a short explanation of the relevant parameters and their proposed settings:</p>
<div>
<dl>
<dt><span>number of background threads</span></dt>
<dd>
<p>This parameter defines the maximum number of threads that are allowed in parallel when importing film rolls or doing other background stuff. For obvious reasons on 32-bit systems you can only have one thread eating resources at a time. So you need set this parameter to 1; anything higher will kill you.</p>
</dd>
<dt><span>host memory limit (in MB) for tiling</span></dt>
<dd>
<p>This parameter tells darktable how much memory (in MB) it should assume is available to store image buffers during module operations. If an image can not be processed within these limits in one chunk, tiling will take over and process the image in several parts, one after the other. Set this to the lowest possible value of 500 as a starting point. You might experiment later whether you can increase it a bit in order to reduce the overhead of tiling.</p>
</dd>
<dt><span>minimum amount of memory (in MB) for a single buffer in tiling</span></dt>
<dd>
<p>This is a second parameter that controls tiling. It sets a lower limit for the size of intermediate image buffers in megabytes. The parameter is needed to avoid excessive tiling in some cases (for some modules). Set this parameter to a low value of 8. You might tentatively increase it to 16 later.</p>
</dd>
<dt><span>memory in megabytes to use for thumbnail cache</span></dt>
<dd>
<p>This controls how many thumbnails (or mip maps) can be stored in memory at a time. As a starting point set this to something like 256MB. Since darktable 2.0, the cache does allocate a few small buffers per each thumbnail in cache, thus causing significant memory fragmentation. As explained before, this poses a problem for 32-bit systems. For this reason, as of darktable 2.0, 32-bit support is soft-deprecated.</p>
</dd>
</dl>
</div>
<p> </p>
</div>
<div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_818">10.1.6. darktable on 64-bit systems</h3>
</div>
</div>
</div>
<p>There's not much to be said here. Of course also 64-bit systems require a sufficient amount of main memory, so the 4GB plus swap recommendation holds true. On the other hand, 64-bit architectures do not suffer from the specific 32-bit limitations like small address space and fragmentation madness.</p>
<p>Most modern Intel or AMD 64-bit CPUs will have available address space in the range of several Terabytes. The word <span>“<span>modern</span>”</span> is relative in this context: all AMD and Intel CPUs introduced since 2003 and 2004, respectively, offer a 64-bit mode. Linux 64-bit has been available for many years.</p>
<p>All relevant Linux distributions give you the choice to install a 32-bit or a 64-bit version with no added costs. You can even run old 32-bit binaries on a 64-bit Linux. The only thing you need to do: invest some time into the migration. In the end we strongly recommend moving to a 64-bit version of Linux. There really is no reason not to upgrade to 64-bit.</p>
<p>On a 64-bit system you can safely leave the tiling related configuration parameters at their defaults: <span>“<span>host memory limit (in MB) for tiling</span>”</span> should have a value of 1500 and <span>“<span>minimum amount of memory (in MB) for a single buffer in tiling</span>”</span> should be set to 16. In case you are migrating from a 32-bit to a 64-bit system you will need to check these settings and manually change them if needed in darktable's preference dialog.</p>
<p>Typically there is no need to restrict oneself in the number of background threads on a 64-bit system. On a multi-processor system a number of two to eight threads can speed up thumbnail generation considerably versus only one thread. The reason is not so much taking maximum advantage of all your CPU cores – darktable's pixelpipe anyhow uses all of them in parallel – but hiding I/O latency.</p>
<p>One exception is worth to be mentioned. If you use darktable to process stitched panoramas, e.g. TIFFs as generated by Hugin, these images can reach considerable sizes. Each background thread needs to allocate enough memory to keep one full image plus intermediates and output in its buffers. This may quickly run even a well equipped 64-bit system out of memory. In that case lower the number of background threads to only one.</p>
<div>
<div>
<div>
<h2 id="sigil_toc_id_819">10.2. darktable and OpenCL</h2>
</div>
</div>
</div>
<p>darktable can use GPU acceleration via OpenCL to improve performance.</p>
<div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_820">10.2.1. The background</h3>
</div>
</div>
</div>
<p>Processing high resolution images is a demanding task needing a modern computer. Both in terms of memory requirements and in terms of CPU power, getting the best out of a typical 15, 20 or 25 Megapixel image can quickly bring your computer to its limits.</p>
<p>darktable's requirements are no exception. Our decision to not compromise processing quality, has led to all calculations being done on 4 x 32bit floating point numbers. This is slower than <span>“<span>ordinary</span>”</span> 8 or 16bit integer algebra, but eliminates all problems of tonal breaks or loss of information.</p>
<p>A lot of hand optimization has been invested to make darktable as fast as possible. If you run a current version of darktable on a modern computer, you might not notice any <span>“<span>slowness</span>”</span>. However, there are conditions and certain modules where you will feel (or hear from the howling of your CPU fan) how much your poor multi-core processor has to struggle.</p>
<p>That's where OpenCL comes in. OpenCL allows us to take advantage of the enormous power of modern graphics cards. Gamer's demand for high detailed 3D worlds in modern ego shooters has fostered GPU development. ATI, NVIDIA and Co had to put enormous processing power into their GPUs to meet these demands. The result is modern graphics cards with highly parallelized GPUs to quickly calculate surfaces and textures at high frame rates.</p>
<p>You are not a gamer and you don't take advantage of that power? Well, then you should at least use it in darktable! For the task of highly parallel floating point calculations modern GPUs are much faster than CPUs. That is especially true, when you want to do the same few processing steps over millions of items. Typical use case: processing of megapixel images.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_821">10.2.2. How OpenCL works</h3>
</div>
</div>
</div>
<p>As you can imagine, hardware architectures of GPUs can vary significantly. There are different manufacturers, and even different generations of GPUs from the same manufacturer may differ. At the same time GPU manufacturers don't normally disclose all hardware details of their products to the public. One of the known consequences is the need to use proprietary drivers under Linux, if you want to take full advantage of your graphics card.</p>
<p>Fortunately an industry consortium lead by The Khronos Group has developed an open, standardized interface called OpenCL. It allows the use of your GPU as a numerical processing device. OpenCL offers a C99-like programming language with a strong focus on parallel computing. An application that wants to use OpenCL will need OpenCL source code that it hands over to a hardware specific OpenCL compiler at run-time. This way the application can use OpenCL on different GPU architectures (even at the same time). All hardware <span>“<span>secrets</span>”</span> are hidden in this compiler and are normally not visible to the user (or the application). The compiled OpenCL code is loaded onto your GPU and – with certain API calls – it is ready to do calculations for you.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_822">10.2.3. How to activate OpenCL in darktable</h3>
</div>
</div>
</div>
<p>Using OpenCL in darktable requires that your PC is equipped with a suitable graphics card and that it has the required libraries in place. Namely modern graphics cards from NVIDIA and AMD come with full OpenCL support. The OpenCL compiler is normally shipped as part of the proprietary graphics driver; it is used as a dynamic library called <span>“<span>libOpenCL.so</span>”</span>. This library must be in a folder where it is found by your system's dynamic linker.</p>
<p>When darktable starts, it will first try to find and load libOpenCL.so and – on success – check if the available graphics card comes with OpenCL support. A sufficient amount of graphics memory (1GB+) needs to be available to take advantage of the GPU. If that is OK, darktable tries to setup its OpenCL environment: a processing context needs to be initialized, a calculation pipeline to be started, OpenCL source code files (extension is .cl) need to be read and compiled and the included routines (called OpenCL kernels) need to be prepared for darktable's modules. If all that is done, the preparation is finished.</p>
<p>Per default OpenCL support is activated in darktable if all the above steps were successful. If you want to de-activate it you can do so in <span>“<span>core options</span>”</span> (<a title="8.2. Core options" href="../Text/preferences.xhtml#sigil_toc_id_5">Section 8.2, “Core options”</a>) by unchecking <span>“<span>activate opencl support</span>”</span>. This configuration parameter also tells you if OpenCL initialization failed: it is greyed out in that case.</p>
<p>You can at any time switch OpenCL support off and on; this will happen immediately. Depending on the type of modules you are using, you will notice the effect as a general speed-up during interactive work and during export. Most modules in darktable can take advantage of OpenCL but not all modules are demanding enough to make a noticeable difference. In order to feel a real difference, take modules like&nbsp;<a title="3.4.1.3. Shadows and Highlights" href="../Text/darkroom.xhtml#sigil_toc_id_50"><span><em>shadows and highlights</em></span></a>, <a title="3.4.4.1. Sharpen" href="../Text/darkroom.xhtml#sigil_toc_id_66"><span><em>sharpen</em></span></a>, <a title="3.4.5.8. Lowpass" href="../Text/darkroom.xhtml#sigil_toc_id_633"><span><em>lowpass</em></span></a>, <a title="3.4.5.8. Lowpass" href="../Text/darkroom.xhtml#sigil_toc_id_67"><span><em>highpass</em></span></a> or even more extreme <a title="3.4.4.2. Equalizer" href="../Text/darkroom.xhtml#sigil_toc_id_38"><span><em>equalizer</em></span></a> and&nbsp;<a title="3.4.4.3. Denoise – profiled" href="../Text/darkroom.xhtml#sigil_toc_id_37"><span><em>profiled denoise</em></span></a>.</p>
<p>If you are interested in profiling figures, you can start darktable with command line parameters <span>“<span>-d opencl -d perf</span>”</span>. After each run of the pixelpipe you will get a detailed allocation of processing time to each module plus an even more fine grained profile for all used OpenCL kernels.</p>
<p>Besides the speed-up you should not see any difference in the results between CPU and GPU processing. Except of rounding errors, the results are designed to be identical. If, for some reasons, darktable fails to properly finish a GPU calculation, it will normally notice and automatically (and transparently) fall back to CPU processing.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_823">10.2.4. Setting up OpenCL on your system</h3>
</div>
</div>
</div>
<p>The huge diversity of systems and the marked differences between OpenCL vendors and driver versions makes it impossible to give an comprehensive overview of how to setup OpenCL. We only can give you an example, in this case for NVIDIA driver version 331.89 on Ubuntu 14.04. We hope that this will serve you as a first impression and will help to solve possible problems of your specific setup.</p>
<p>The principle OpenCL function flow is like this:</p>
<p>darktable -&gt; libOpenCL.so -&gt; libnvidia-opencl.so.1 -&gt; kernel driver module(s) -&gt; GPU</p>
<p> </p>
<div>
<ul>
<li>
<p>darktable dynamically loads <code>libOpenCL.so</code>, a system library which must be accessible to the system's dynamic loader (<code>ld.so</code>).</p>
</li>
<li>
<p><code>libOpenCL.so</code> will read the vendor specific information file (<code>/etc/OpenCL/vendors/nvidia.icd</code>) to find the library which contains the vendor specific OpenCL implementation.</p>
</li>
<li>
<p>The vendor specific OpenCL implementation comes as a library <code>libnvidia-opencl.so.1</code> (which in our case is a symbolic link to <code>libnvidia-opencl.so.331.89</code>).</p>
</li>
<li>
<p><code>libnvidia-opencl.so.1</code> needs to talk to the vendor specific kernel modules <code>nvidia</code> and <code>nvidia_uvm</code> via device special files <code>/dev/nvidia0</code>, <code>/dev/nvidiactl</code>, and <code>/dev/nvidia-uvm</code>.</p>
</li>
</ul>
</div>
<p> </p>
<p>At system startup the required device special files (/dev/nvidia*) need to be created. If this does not happen on your system by default, the easiest way to set them up and make sure all modules are loaded is installing the <code>nvidia-modprobe</code> package (which, at the time of this writing, is only available for <span>“<span>utopic</span>”</span>, but works well with <span>“<span>trusty</span>”</span> and <span>“<span>Mint 17</span>”</span>). You can grab it at <a href="http://packages.ubuntu.com/utopic/nvidia-modprobe" target="_top">this site</a>.</p>
<p>A user account which wants to make use of OpenCL from within darktable needs to have read-write access to NVIDIA's device special files. On some systems these files allow world read-write access by default, which avoids permission issues but might be debatable in terms of system security. Other systems restrict the access to a user group, e.g. <span>“<span>video</span>”</span>. In that case your user account has to be member of that group.</p>
<p>To summarise, the packages which needed to be installed in this specific case were:</p>
<div>
<ul>
<li>
<p>nvidia-331 (331.89-0ubuntu1~xedgers14.04.2)</p>
</li>
<li>
<p>nvidia-331-dev (331.89-0ubuntu1~xedgers14.04.2)</p>
</li>
<li>
<p>nvidia-331-uvm (331.89-0ubuntu1~xedgers14.04.2)</p>
</li>
<li>
<p>nvidia-libopencl1-331 (331.89-0ubuntu1~xedgers14.04.2)</p>
</li>
<li>
<p>nvidia-modprobe (340.24-1)</p>
</li>
<li>
<p>nvidia-opencl-dev:amd64 (5.5.22-3ubuntu1)</p>
</li>
<li>
<p>nvidia-opencl-icd-331 (331.89-0ubuntu1~xedgers14.04.2)</p>
</li>
<li>
<p>nvidia-settings (340.24-0ubuntu1~xedgers14.04.1)</p>
</li>
<li>
<p>nvidia-settings-304 (340.24-0ubuntu1~xedgers14.04.1)</p>
</li>
<li>
<p>nvidia-libopencl1-331 (331.89-0ubuntu1~xedgers14.04.2)</p>
</li>
<li>
<p>nvidia-opencl-dev:amd64 (5.5.22-3ubuntu1)</p>
</li>
<li>
<p>nvidia-opencl-icd-331 (331.89-0ubuntu1~xedgers14.04.2)</p>
</li>
<li>
<p>opencl-headers (1.2-2013.10.23-1)</p>
</li>
</ul>
</div>
<p> </p>
<p>The list of NVIDIA related kernel modules as reported by <code>lsmod</code> is:</p>
<p> </p>
<pre>nvidia
nvidia_uvm
</pre>
<p> </p>
<p>The list of NVIDIA related device special files (<code>ls -l /dev/nvidia*</code>) should read like:</p>
<p> </p>
<pre>crw-rw-rw- 1 root root 195, 0 Jul 28 21:13 /dev/nvidia0
crw-rw-rw- 1 root root 195, 255 Jul 28 21:13 /dev/nvidiactl
crw-rw-rw- 1 root root 250, 0 Jul 28 21:13 /dev/nvidia-uvm
</pre>
<p> </p>
<p>Beware that the major/minor numbers (e.g. 250/0 for <code>/dev/nvidia-uvm</code> in this example) may vary depending on your system.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_824">10.2.5. Possible problems and solutions</h3>
</div>
</div>
</div>
<p>darktable will detect OpenCL run-time problems automatically. It will then reprocess everything on CPU; only speed is affected, the final result should not be endangered.</p>
<p>There can be various reasons why OpenCL could fail during initialization phase. We depend on hardware requirements and on the presence of certain drivers and libraries. In addition all these have to fit in terms of maker model and revision number. If anything does not fit, e.g. your graphics driver (loaded as a kernel module) does not match the version of your libOpenCL.so, OpenCL support is likely not available.</p>
<p>In that case, the best thing to do is start darktable from a console with</p>
<p> </p>
<pre>darktable -d opencl
</pre>
<p> </p>
<p>This will give additional debugging output about the initialization and use of OpenCL. First see if you find a line that starts with <span>“<span>[opencl_init] FINALLY ...</span>”</span> This should tell you, if OpenCL support is available for you or not. If initialization failed, look at the messages above for anything that reads like <span>“<span>could not be detected</span>”</span> or <span>“<span>could not be created</span>”</span>. Check if there is a hint about where it failed.</p>
<p>Here are a few cases observed in the past:</p>
<div>
<ul>
<li>
<p>darktable might tell you that no OpenCL aware graphics card is detected or that the available memory on your GPU is too low and the device is discarded. In that case you might need to buy a new card, if you really want OpenCL support.</p>
</li>
<li>
<p>darktable might find your libOpenCL.so but then tell you that it couldn't get a platform. NVIDIA drivers will often give error code -1001 in that case. This happens because libOpenCL.so is only a wrapper library. For the real work further libraries – specific to vendor, device and driver – need to be loaded. This failed for some reason. There is a structure of files in /etc/OpenCL on your system that libOpenCL.so consults to find these libraries. Check if you find something fishy in there and try to fix it. Often the needed libraries cannot be found by your system's dynamic loader. Giving full path names might help.</p>
</li>
<li>
<p>darktable might also tell you that a context could not be created. This often indicates a version mismatch between (loaded) graphics driver and libOpenCL. Check if you have left-over kernel modules or graphics libraries of an older install and take appropriate action. In doubt, make a clean reinstall of your graphics driver. Sometimes, immediately after a driver update, the loaded kernel driver does not match the newly installed libraries: reboot your system in that case.</p>
</li>
<li>
<p>darktable might crash in very rare cases directly during startup. This can happen if your OpenCL setup is completely broken or if driver/library contains a severe bug. If you can't fix it, you can still use darktable with option <span>“<span>--disable-opencl</span>”</span>, which will skip the entire OpenCL initialization step.</p>
</li>
<li>
<p>darktable might fail to compile its OpenCL source files at run-time. In that case you will get a number of error messages looking like typical compiler errors. This could indicate an incompatibility between your OpenCL implementation and our interpretation of the standard. In that case visit us in IRC in #darktable on FreeNode or on the developers mailing list at darktable-dev@lists.darktable.org and report the problem. Chances are good that we can help you. Please also report if you see significant differences between CPU and GPU processing of an image!</p>
</li>
</ul>
</div>
<p>There also exists a few on-CPU implementations of OpenCL. These come as drivers provided by INTEL or AMD. We observed that they do not give us any speed gain versus our hand-optimized CPU code. Therefore we simply discard these devices by default. This behavior can be changed by setting the configuration variable opencl_use_cpu_devices to TRUE.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_825">10.2.6. Setting up OpenCL for AMD/ATI devices</h3>
</div>
</div>
</div>
<p>While NVIDIA devices and most modern AMD/ATI devices will most often run out of the box, there is more to do for older AMD/ATI graphics cards, namely those prior to the HD7xxx series. This starts with the fact that those devices will only report to darktable part of their total GPU memory. For a 1GB device this typically amounts to 512MB, a value which darktable in its standard configuration will refuse as not being sufficient for its tasks. Consequence: the device will not be used.</p>
<p>On the web you might find as a tip to set environment variable GPU_MAX_HEAP_SIZE to a value of 100 in this case. Indeed this will cause the AMD/ATI driver to report the full installed memory to darktable. However, there is a problem. On many (most?) cards this will cause buffers to be allocated on your computer (host) not on the video card! In this case all memory accesses will need to go through the slow PCIe bus. This will cost you a factor of 10x or more in performance and will render OpenCL useless for you, especially when exporting files.</p>
<p>Another environment variable which changes driver behavior is GPU_MAX_ALLOC_PERCENT. You could set this to 100 in order to allow memory allocations as high as 1GB on your AMD/ATI card. The problem is, this tends to cause darktable to crash sooner or later.</p>
<p>Our recommendation is to leave these settings untouched. Often your card will be recognized with 512MB memory and a maximum allocation size of 128MB. There are three configuration parameter which you set in file $HOME/.config/darktable/darktablerc to get things running. Here are the details:</p>
<div>
<dl>
<dt><span><code>opencl_memory_requirement</code></span></dt>
<dd>
<p>Set this parameter to 500 so that darktable will accept your 512MB graphics memory as being sufficient in memory.</p>
</dd>
<dt><span><code>opencl_memory_headroom</code></span></dt>
<dd>
<p>This parameter controls how much graphics memory (out of the reported one) darktable should leave untouched for driver and display use. As for AMD/ATI devices we anyhow only can get half of the available RAM it's safe to set this to zero. So all of the 512MB can be used by darktable.</p>
</dd>
<dt><span><code>opencl_avoid_atomics</code></span></dt>
<dd>
<p>Atomic operations in OpenCL are a special way of data synchronization. They are only used in a few kernels. Unfortunately, some (most?) AMD/ATI devices are extremely slow in processing atomics. It's better to process the affected modules on CPU rather than accepting an ultra-slow GPU codepath. Set this parameter to TRUE if you experience slow processing of modules like&nbsp;<a title="3.4.1.3. Shadows and Highlights" href="../Text/darkroom.xhtml#sigil_toc_id_50"><span><em>shadows and highlights</em></span></a>,&nbsp;<a title="3.4.3.7. Monochrome" href="../Text/darkroom.xhtml#sigil_toc_id_63"><span><em>monochrome</em></span></a>, <a title="3.4.2.5. Local contrast" href="../Text/darkroom.xhtml#sigil_toc_id_59"><span><em>local contrast</em></span></a>, or <a title="3.4.2.7. Global tonemap" href="../Text/darkroom.xhtml#sigil_toc_id_414"><span><em>global tonemap</em></span></a> or if you even get intermittent system freezes.</p>
</dd>
</dl>
</div>
<p> </p>
<p>These recommendations do not apply to the more recent Radeon HD7xxx series with GCN architecture. Besides being very fast in terms of GPU computing they normally run out of the box. You only might consider to try some of the performance optimization options which are described in the following section.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_826">10.2.7. OpenCL performance optimization</h3>
</div>
</div>
</div>
<p>There are some configuration parameters in $HOME/.config/darktable/darktablerc that help to finetune your system's OpenCL performance. Performance in this context mostly means the latency of darktable during interactive work, i.e. how long it takes to reprocess your pixelpipe. For a comfortable workflow it is essential to keep latency low.</p>
<p>In order to get profiling info you start darktable from a terminal with</p>
<p> </p>
<pre>darktable -d opencl -d perf
</pre>
<p> </p>
<p>After each reprocessing of pixelpipe – caused by module parameter change, zooming, panning, etc. – you will get the total time and the time spent in each of our OpenCL kernels. The most reliable value is the total time spent in pixelpipe. Please note that the timings given for each individual module are unreliable when running the OpenCL pixelpipe asynchronously (see opencl_async_pixelpipe below).</p>
<p>To allow for a fast pixelpipe processing with OpenCL it is essential that we keep the GPU busy. Any interrupts or a stalled data flow will add to the total processing time. This is especially important for the small image buffers we need to handle during interactive work. They can be processed quickly by a fast GPU. However, even short-term stalls of the pixelpipe will easily become a bottleneck.</p>
<p>On the other hand darktable's performance during file exports is more or less only governed by the speed of our algorithms and the horse-power of your GPU. Short-term stalls will not have a noticeable effect on the total time of an export.</p>
<p>darktable comes with default settings that should deliver a decent GPU performance on most systems. However, if you want to fiddle around a bit by yourself and try to optimize things further, here is a description of the relevant configuration parameters.</p>
<div>
<dl>
<dt><span><code>opencl_async_pixelpipe</code></span></dt>
<dd>
<p>This boolean flag controls how often we block the OpenCL pixelpipe and get a status on success/failure of all the kernels that have been run. For optimum latency set this to TRUE, so darktable runs the pixelpipe asynchronously and tries to use as few interrupts as possible. If you experience OpenCL errors like failing kernels, set the parameter to FALSE. darktable will then interrupt after each module so you can more easily isolate the problem. Problems have been reported with some older ATI/AMD cards, like HD57xx, which can produce garbled output if this parameter is set to TRUE. If in doubt, leave it at its default FALSE.</p>
</dd>
<dt><span><code>opencl_number_event_handles</code></span></dt>
<dd>
<p>Event handles are used so we can monitor success/failure of kernels and profiling info even if the pixelpipe is run asynchronously. The number of event handles is a limited resource of your OpenCL driver. For sure we can recycle them, but there is a limited number that we can use at the same time. Unfortunately, there is no way to find out what the resource limits are; so we need to guess. Our default value of 25 is quite conservative. You might want to try if higher values like 100 give better OpenCL performance. If your driver runs out of free handles you would experience failing OpenCL kernels with error code <span>“<span>-5 (CL_OUT_OF_RESOURCES)</span>”</span> or even crashes or system freezes; reduce the number again in that case. A value of 0 will block darktable from using any event handles. This will prevent darktable from properly monitoring the success of your OpenCL kernels but saves some driver overhead. The consequence is that any failures will likely lead to garbled output without darktable taking notice; only recommended if you know for sure that your system runs rock-solid. You can also set this parameter to -1, which means that darktable assumes no restriction in the number of event handles; this is not recommended.</p>
</dd>
<dt><span><code>opencl_synch_cache</code></span></dt>
<dd>
<p>This parameter, if set to TRUE, will force darktable to fetch image buffers from your GPU after each module and store them in its pixelpipe cache. This is a very resource consuming operation. It only makes sense if you have a rather slow GPU. In that case darktable might in fact save some time when module parameters have changed, as it can go back to some cached intermediate state and reprocess only part of the pixelpipe. In most cases this parameter should be set to FALSE (default).</p>
</dd>
<dt><span><code>opencl_micro_nap</code></span></dt>
<dd>
<p>In an ideal case you keep your GPU busy at 100% when reprocessing the pixelpipe. That's good. On the other hand your GPU is also needed to do regular GUI updates. It might happen that there is no sufficient time left for this task. Consequence would by a jerky reaction of your GUI on panning, zooming or when moving sliders. darktable can add small naps into its pixelpipe processing to have the GPU catch some breath and do GUI related stuff. Parameter opencl_micro_nap controls the duration of these naps in microseconds. You need to experiment in order to find an optimum value for your system. Values of 0, 100, 500 and 1000 are good starting points to try. Defaults to 1000.</p>
</dd>
<dt><span><code>opencl_use_pinned_memory</code></span></dt>
<dd>
<p>During tiling huge amounts of memory need to be transferred between host and device. On some devices (namely AMD) direct memory transfers to and from an arbitrary host memory region may give a huge performance penalty. This is especially noticeable when exporting large images. Setting this configuration parameter to TRUE tells darktable to use a special kind of intermediate buffer for host-device data transfers. On some devices this can speed up exporting of large files by a factor of 2 to 3. NVIDIA devices and drivers seem to have a more efficient memory transfer technique even for arbitrary memory regions. As they may not show any performance gain and even may produce garbled output, opencl_use_pinned_memory should be left at its default FALSE for those devices.</p><div>
<div>
<div>
<h3 id="sigil_toc_id_827">10.2.8. OpenCL scheduling profile</h3>
</div>
</div>
</div>
<p>darktable can use the CPU and one or several OpenCL capable GPUs. Depending on the relative performance users can choose among certain scheduling profiles to optimize performance. This is done by the configuration parameter <span>“<span>OpenCL scheduling profile</span>”</span> in the <span>“<span>core options</span>”</span> dialog (<a title="8.2. Core options" href="../Text/preferences.xhtml#sigil_toc_id_5">Section 8.2, “Core options”</a>) which offers the following choices:</p>
<p> </p>
<div>
<table border="0" width="100%"><colgroup><col width="25%"/>
<col width="75%"/>
</colgroup>
<tbody>
<tr>
<td>default</td>
<td>If an OpenCL capable GPU is found darktable uses it for processing the center image view while the preview window (see <a title="3.3.1. Navigation" href="../Text/darkroom.xhtml#sigil_toc_id_267">Section 3.3.1, “Navigation”</a>) is processed on the CPU in parallel. This is the preferred setting for systems with a reasonably fast CPU and a moderately fast GPU. The exact allocation of devices to the various pixelpipe types can be finetuned with the <span>“<span>opencl_device_priority</span>”</span> configuration parameter (see below).</td>
</tr>
<tr>
<td>very fast GPU</td>
<td>With this scheduling profile darktable processes the center image view and the preview window on the GPU sequentially. This is the preferred setting for systems with a GPU that strongly outperforms the CPU.</td>
</tr>
<tr>
<td>multiple GPUs</td>
<td>This setting addresses systems with multiple GPUs whose relative performance does not differ significantly. Whenever a processing job is started darktable uses any currently idle GPU but not the CPU. Users of systems with a variety of GPUs will need better control on their relative priority. They should better select the <span>“<span>default</span>”</span> profile and finetune their system with the <span>“<span>opencl_device_priority</span>”</span> configuration parameter (see below).</td>
</tr>
</tbody>
</table>
</div>
<p> </p>
<p>On first start-up or after any detected change in the GPU configuration of your system darktable tries to identify the best suited profile for you. You can change it at any time in the <span>“<span>core options</span>”</span> dialog (<a title="8.2. Core options" href="../Text/preferences.xhtml#sigil_toc_id_5">Section 8.2, “Core options”</a>) with immediate effect.</p>
</dd>
</dl>
</div>
</div>
</div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_828">10.2.9. Multiple OpenCL devices – manual settings</h3>
</div>
</div>
</div>
<p>The scheduling of OpenCL devices on most typical systems can be optimized using the <span>“<span>OpenCL scheduling profile</span>”</span> settings. However, if your system is equipped with a variety of GPUs you might want to set the relative device priority manually. To do so you need to select the <span>“<span>default</span>”</span> scheduling profile and do your settings in the <span>“<span>opencl_device_priority</span>”</span> configuration parameter.</p>
<p>It is important to understand how darktable uses OpenCL devices. Each processing sequence of an image – to convert an input to the final output using a certain history stack – is run in a so called pixelpipe. There are four different types of pixelpipe in darktable. One type is responsible to process the center image view (or full view) in darkroom mode, another pixelpipe processes the preview image (navigation window) top left in darkroom mode. Of each of these two pixelpipe there can be one at a time – with the full and the preview pixelpipe running in parallel. In addition there can be multiple parallel pixelpipes doing file exports and there can be multiple parallel pixelpipes generating thumbnails. If an OpenCL device is available darktable dynamically allocates it to one specific pixelpipe for one run and releases it afterwards.</p>
<p>The computational demand depends a lot on the pixelpipe type. Preview image and thumbnails have a low resolution and can be processed quickly; center image view is more demanding, let alone the pixelpipe doing a file export.</p>
<p>Configuration parameter <span>“<span>opencl_device_priority</span>”</span> holds a string with the following structure:</p>
<p> </p>
<pre>a,b,c.../k,l,m.../o,p,q.../x,y,z...
</pre>
<p> </p>
<p>Each letter represents one specific OpenCL device. There are four fields in the parameter string separated by a slash, each representing one type of pixelpipe.<span>“<span>a,b,c...</span>”</span> defines the devices that are allowed to process the center image (full) pixelpipe. Likewise devices <span>“<span>k,l,m...</span>”</span> can process the preview pixelpipe, devices <span>“<span>o,p,q...</span>”</span> the export pixelpipes and finally devices <span>“<span>x,y,z...</span>”</span> the thumbnail pixelpipes. An empty field means that no OpenCL device may serve this type of pixelpipe.</p>
<p>darktable has an internal numbering system, where the first available OpenCL device will receive number <span>“<span>0</span>”</span>. All further devices are numbered consecutively. This number together with the device name is displayed when you start darktable with <span>“<span>darktable -d opencl</span>”</span>. You can specify a device either by number or by name (upper/lower case and whitespace do not matter). If you have more than one device – all with the same name – you need to use the device numbers in order to differentiate them.</p>
<p>A device specifier can be prefixed with an exclamation mark <span>“<span>!</span>”</span>, in which case the device is excluded from processing this pixelpipe. You can also give an asterisk <span>“<span>*</span>”</span> as a wildcard, representing all devices not mentioned explicitly before in that group.</p>
<p>Sequence order within a group matters. darktable will read the list from left to right and whenever it tries to allocate an OpenCL device to a pixelpipe it will scan the devices in that order, taking the first free device it finds.</p>
<p>If a pixelpipe process is about to be started and if all GPUs in the corresponding group are busy, darktable automatically processes the image on the CPU by default. You can enforce GPU processing by prefixing the list of allowed GPUs with a plus sign<span>“<span>+</span>”</span>. darktable will not use the CPU but rather suspend processing until the next allowed OpenCL device is available.</p>
<p>darktable's default setting for <span>“<span>opencl_device_priority</span>”</span> is:</p>
<p> </p>
<pre>*/!0,*/*/*
</pre>
<p> </p>
<p>Any detected OpenCL device is allowed to process our center view image. The first OpenCL device (0) is not allowed to process the preview pixelpipe. As a consequence, if there is only one GPU owned by your system, preview pixelpipe will always be processed on CPU, keeping your single GPU exclusively for the more demanding center image view. This is a reasonable setting for most systems. No restrictions apply to export and thumbnail pixelpipes.</p>
<p>The default is a good choice if you have only one device. If you have several devices it forms a reasonable starting point. However, as your devices might have quite different levels of processing power, it makes sense to invest a few thoughts and optimize your priority list.</p>
<p>Here is an example. Let's assume we have a system with two devices, a fast Radeon HD7950 and an older and slower GeForce GTS450. darktable (started with <span>“<span>darktable -d opencl</span>”</span>) will report the following devices:</p>
<p> </p>
<pre>[opencl_init] successfully initialized.
[opencl_init] here are the internal numbers and names of
 OpenCL devices available to darktable:
[opencl_init] 0 'GeForce GTS 450'
[opencl_init] 1 'Tahiti'
[opencl_init] FINALLY: opencl is AVAILABLE on this system.
</pre>
<p> </p>
<p>So the GeForce GTS 450 is detected as the first device; the Radeon HD7950 ('Tahiti') as the second one. This order will normally not change unless the hardware or driver configuration is modified. But it's better to use device names rather than numbers to be on the safe side.</p>
<p>As the GTS450 is slower than the HD7950, an optimized opencl_device_priority could look like:</p>
<p> </p>
<pre>!GeForce GTS450,*/!Tahiti,*/Tahiti,*/Tahiti,*
</pre>
<p> </p>
<p>The GTS450 is explicitly excluded from doing the center image pixelpipe; this is reserved to <span>“<span>all</span>”</span> other devices (i.e. the HD7950/Tahiti). Completely the opposite for our preview pixelpipe. Here the Tahiti is excluded, so that only the GTS450 will be allowed to do the work.</p>
<p>For file export and thumbnail generation we want all hands on deck. However, darktable should first look if device Tahiti is free, because it's faster. If that's not the case, all other devices – in fact only the GTS450 – are checked.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_829">10.2.10. OpenCL still does not run for me!</h3>
</div>
</div>
</div>
<p>As has been said before OpenCL systems come with a huge variety of setups: different GPU manufacturers, different GPU models, varying amounts of GPU memory, different drivers, different distributions etc. Many of the potential problems will only appear with a very specific combination of those factors.</p>
<p>As we developers of darktable on our computers only have access to a small fraction of those variations, please understand that we might not be able to fix your specific problem. There is not much we can do, if there is no way for us to reproduce.</p>
<p>If nothing else helps, the best option might be to start darktable with</p>
<p> </p>
<pre>darktable --disable-opencl
</pre>
<p> </p>
<p>In the end there is nothing in darktable which only runs on GPU. Don't let OpenCL discourage you; also darktable's CPU code is highly optimized for performance!</p>
<h2 id="sigil_toc_id_8">10.3. Using darktable-chart<br/></h2>
<div>
<div>
<div>
<h3 id="sigil_toc_id_830">10.3.1. Overview</h3>
</div>
</div>
</div>
<p>With <code>darktable-chart</code> we provide a tool for extracting luminance and color values out of images taken from color reference cards like IT8.7/1 charts. Its main purpose is to compare a source image (typically a largely unprocessed raw image) to a target image (typically a JPEG image created in-camera) and produce a darktable style that is able to convert luminance and color values of the source image to produce the target image. This style employs the <span><em>base curve</em></span> module, the <span><em>input color profile</em></span>, and the <span><em>color look up table</em></span> module for that purpose (see <a title="3.4.1.4. Base curve" href="../Text/darkroom.xhtml#sigil_toc_id_186">Section 3.4.1.4, “Base curve”</a>, <a title="3.4.3.11. Input color profile" href="../Text/darkroom.xhtml#sigil_toc_id_266">Section 3.4.3.11, “Input color profile”</a>, and <a title="3.4.3.6. Color look up table" href="../Text/darkroom.xhtml#sigil_toc_id_442">Section 3.4.3.6, “Color look up table”</a>).</p>
<p>Some cameras are particularly advanced in offering various film simulation modes of your choice. With the help of <code>darktable-chart</code> and the underlying modules you can now create styles that replicate these film simulations from within darktable.</p>

</div>
<div>
<div>
<div>
<h3 id="sigil_toc_id_831">10.3.2. Usage</h3>
</div>
</div>
</div>
<p> </p>
<div>
<table border="0" width="100%"><colgroup><col width="60%"/>
<col width="40%"/>
</colgroup>
<tbody>
<tr>
<td>The tool is organized into three tabs in the upper part and a text output frame in the lower part.</td>
<td>
<div><img alt="darktable_chart_overview" src="../Images/darktable_chart_overview.jpg" width="100%"/><br/>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<p> </p>
<p>The first tab is used to define the source image, the second tab defines the reference (target) and the third tab contains the controls to generate the resulting darktable style.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_832">10.3.3. Source image</h3>
</div>
</div>
</div>
<p>In the <span>“<span>source image</span>”</span> tab you set your source image which requires two elements. The first element is an input file in Lab Portable Float Map format (extension <span><em>.pfm</em></span>). The source file represents the largely unmodified data as the camera sees them. Details on taking photos of a color reference card and producing a <span><em>.pfm</em></span> output file are described below. The second element is a chart file that contains a formal description of the underlying color reference card's layout (extension <span><em>.cht</em></span>). Chart files are usually shipped with your color reference card or can be downloaded.</p>
<p>In real life the photo taken from the color reference card will show some perspective distortions relative to the layout defined in the chart file. For that reason the layout is displayed as a grid over the image and can be modified.</p>
<p> </p>
<div>
<table border="0" width="100%"><colgroup><col width="60%"/>
<col width="40%"/>
</colgroup>
<tbody>
<tr>
<td>You can move the corners of the grid using the mouse to reach best alignment of grid and image.</td>
<td>
<div><img alt="darktable_chart_source" src="../Images/darktable_chart_source.jpg" width="100%"/><br/>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<p> </p>
<p>A rectangular frame is displayed for each patch and defines the area from which<code>darktable-chart</code> will actually sample the needed input data. It may be required to modify the size of these rectangles so that the sampling area is big enough but does not overlap with neighboring patches. Use the <span>“<span>size</span>”</span> slider in the upper right part of the GUI. Higher values lead to smaller sizes.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_833">10.3.4. Reference values</h3>
</div>
</div>
</div>
<p>The <span>“<span>reference values</span>”</span> tab determines the target values to which the source image is to be modified by the resulting style. You can either supply reference values in the form of measured data of your color reference card (mode <span>“<span>cie/it8 file</span>”</span>), or you supply a photographic image (mode <span>“<span>color chart image</span>”</span>) much in the same way as described above. This second image must also be supplied in Lab Portable Float Map format. There is no need to supply the chart file again as <code>darktable-chart</code> takes the same one as defined under <span>“<span>source image</span>”</span>. You only need to again align the layout grid and the image and potentially adjust the <span>“<span>size</span>”</span> slider.</p>
<p>In a typical use case the second image will be based on a JPEG file produced in-camera. This way you can create a style to simulate the in-camera processing within darktable.</p>
<p>In the lower text output frame you see the color values extracted from the available data for each individual color patch. The first column gives the name of the patch, the second and third column show the corresponding color values of the source image in RGB and Lab format, respectively. The fourth column contains the Lab value coming from the reference (or from the chart file if no reference image has been given). Finally, the fifth and sixth columns display how strongly source and reference values deviate in terms of delta E values.</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_834">10.3.5. Process</h3>
</div>
</div>
</div>
<p> </p>
<div>
<table border="0" width="100%"><colgroup><col width="60%"/>
<col width="40%"/>
</colgroup>
<tbody>
<tr>
<td>If all required settings in <span>“<span>source image</span>”</span> and <span>“<span>reference values</span>”</span> are ready you can move to the <span>“<span>process</span>”</span> tab.</td>
<td>
<div><img alt="darktable_chart_process" src="../Images/darktable_chart_process.jpg" width="100%"/><br/>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<p> </p>
<p>You first need to tell <code>darktable-chart</code> which of the patches represent the gray ramp. In the screenshot displayed further above the gray ramp is positioned in the lower part of the color reference chart, denoted as <span>“<span>GS00...GS23</span>”</span>.</p>
<p>The input <span>“<span>number of final patches</span>”</span> defines how many editable color patches the resulting style will use within the <span><em>color look up table</em></span> module (for more details see <a title="3.4.3.6. Color look up table" href="../Text/darkroom.xhtml#sigil_toc_id_442">Section 3.4.3.6, “Color look up table”</a>).</p>
<p>By clicking the <span>“<span>process</span>”</span> button you start the calculation.</p>
<p>The quality of the result in terms of average delta E and maximum delta E are displayed below the button. These data show how close the resulting style applied to the source image will be able to match the reference values – the lower the better.</p>
<p> </p>
<div>
<table border="0" width="100%"><colgroup><col width="60%"/>
<col width="40%"/>
</colgroup>
<tbody>
<tr>
<td>Once you are happy with the result you can click on <span>“<span>export</span>”</span> and save the generated style.</td>
<td>
<div><img alt="darktable_chart_save" src="../Images/darktable_chart_save.jpg" width="100%"/><br/>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<p> </p>
<p>You supply a style name and a style description under which the style will later appear in darktable. <code>darktable-chart</code> saves the style as a <span><em>.dtstyle</em></span> file which can be imported into darktable (see <a title="2.3.8. Styles" href="../Text/lighttable.xhtml#sigil_toc_id_146">Section 2.3.8, “Styles”</a>) and shared with others.</p>
<p>The <span>“<span>export raw data as csv</span>”</span> button allows you to save the extracted raw data as a CSV file for debugging purposes or later usage. <code>darktable-chart</code> offers a command line option to produce a style with the desired number of final patches from a supplied CSV file (see <a title="1.1.4. darktable-chart binary" href="../Text/Overview.xhtml#sigil_toc_id_7">Section 1.1.4, “<code>darktable-chart</code> binary”</a>).</p>
<div>
<div>
<div>
<h3 id="sigil_toc_id_835">10.3.6. Making input images for <code>darktable-chart</code> </h3>
</div>
</div>
</div>
<p>To start with, you need a suitable photo of your color reference card in RAW+JPEG format. It goes beyond the scope of this manual to explain the details of how to take this photo, but in a nutshell you need to make the shot on a sunny day around midday with the light source (sun) shining at an angle onto the card. You need to avoid any glare in the image. The neutral white color patch in the gray ramp (G00) should end up at the L value specified in the description of your card. Often this is L=92 and requires you to overexpose the shot by about 1/3 EV. Ideally you make several shots with slightly different exposures to later select the right one in darktable. Make sure that the chart fills up most of the frame. Take a lens with a <span>“<span>normal</span>”</span> focal length (e.g. 50mm equivalent) and stop down a bit to avoid vignetting.</p>
<p>You then open the raw file in darktable and disable most modules, especially <span><em>base curve</em></span>. Select the standard input matrix in the <span><em>input color profile</em></span> module and disable gamut clipping. Select <span>“<span>camera white balance</span>”</span> in the <span><em>white balance</em></span> module (see&nbsp;<a title="3.4.1.4. Base curve" href="../Text/darkroom.xhtml#sigil_toc_id_186">Section 3.4.1.4, “Base curve”</a>, <a title="3.4.3.11. Input color profile" href="../Text/darkroom.xhtml#sigil_toc_id_266">Section 3.4.3.11, “Input color profile”</a>, and&nbsp;<a title="3.4.1.10. White balance" href="../Text/darkroom.xhtml#sigil_toc_id_32">Section 3.4.1.10, “White balance”</a>).</p>
<p>There is a special situation if your camera automatically applies some lens corrections, namely vignetting correction, to the resulting JPEG file. In this case you need to activate the <span><em>lens correction</em></span> module in darktable so that raw processing matches the JPEG in this respect (see <a title="3.4.4.8. Lens correction" href="../Text/darkroom.xhtml#sigil_toc_id_48">Section 3.4.4.8, “Lens correction”</a>).</p>
<p>To output your image you go to the <span>“<span>export</span>”</span> module in darktable (see <a title="2.3.12. Export selected" href="../Text/lighttable.xhtml#sigil_toc_id_3">Section 2.3.12, “Export selected”</a>).</p>
<p>You need to select <span>“<span>Lab</span>”</span> as output color profile. This color space is not visible in the combobox by default. You first need to enable it by setting allow_lab_output to TRUE in <code>$HOME/.config/darktable/darktablerc</code>. Alternatively, you can start darktable with:</p>
<p> </p>
<pre>darktable --conf allow_lab_output=true
</pre>
<p> </p>
<p>Then select <span>“<span>PFM (float)</span>”</span> as output format and press <span>“<span>export</span>”</span> to generate the source image file.</p>
<p>In a similar way you produce the corresponding reference (target) image from the JPEG. Also this time you need to disable all modules and export with <span>“<span>Lab</span>”</span> output color profile in <span>“<span>PFM (float)</span>”</span> format.</p>
</body>
</html>